#define TINYGLTF_IMPLEMENTATION
#define STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <iostream>
#include "TextureBuilder.h"
#include "Model_3DS.h"
#include <filesystem>
//#include "Model_GLB.h"
#include "GLTexture.h"
#include <glut.h>
#include "tiny_gltf.h"
#include <glew.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <unordered_map>
#include <string>

#define M_PI 3.14159265358979323846


GLuint shaderProgram;


class Vector
{
public:
	GLdouble x, y, z;
	Vector() {}
	Vector(GLdouble _x, GLdouble _y, GLdouble _z) : x(_x), y(_y), z(_z) {}
	//================================================================================================//
	// Operator Overloading; In C++ you can override the behavior of operators for you class objects. //
	// Here we are overloading the += operator to add a given value to all vector coordinates.        //
	//================================================================================================//
	void operator +=(float value)
	{
		x += value;
		y += value;
		z += value;
	}

    float distanceToNoY(const Vector& other) const {
        return std::sqrt(std::pow(x - other.x, 2) + std::pow(z - other.z, 2));
    }

	void print() const {
		std::cout << "Vector(" << x << ", " << y << ", " << z << ")" << std::endl;
	}
};




class GLTFModel {
public:
	bool LoadModel(const std::string& filename) {
		tinygltf::TinyGLTF loader;
		std::string err;
		std::string warn;

		bool ret = loader.LoadASCIIFromFile(&model, &err, &warn, filename);

		if (!warn.empty()) {
			std::cout << "GLTF loading warning: " << warn << std::endl;
		}

		if (!err.empty()) {
			std::cerr << "GLTF loading error: " << err << std::endl;
		}

		if (!ret) {
			std::cerr << "Failed to load glTF: " << filename << std::endl;
			return false;
		}

		return true;
	}

	void DrawModel(const glm::mat4& transform = glm::mat4(1.0f)) const {
		const tinygltf::Scene& scene = model.scenes[model.defaultScene];
		for (size_t i = 0; i < scene.nodes.size(); ++i) {
			DrawNode(scene.nodes[i], transform);
		}
	}

private:
	tinygltf::Model model;
	mutable std::unordered_map<int, GLuint> textureCache;

	void DrawNode(int nodeIndex, const glm::mat4& parentTransform) const {
		const tinygltf::Node& node = model.nodes[nodeIndex];

		glm::mat4 localTransform = glm::mat4(1.0f);

		if (node.matrix.size() == 16) {
			localTransform = glm::make_mat4(node.matrix.data());
		}
		else {
			if (node.translation.size() == 3) {
				localTransform = glm::translate(localTransform,
					glm::vec3(node.translation[0], node.translation[1], node.translation[2]));
			}

			if (node.rotation.size() == 4) {
				glm::quat q = glm::quat(node.rotation[3], node.rotation[0],
					node.rotation[1], node.rotation[2]);
				localTransform = localTransform * glm::mat4_cast(q);
			}

			if (node.scale.size() == 3) {
				localTransform = glm::scale(localTransform,
					glm::vec3(node.scale[0], node.scale[1], node.scale[2]));
			}
		}

		glm::mat4 nodeTransform = parentTransform * localTransform;

		if (node.mesh >= 0) {
			DrawMesh(model.meshes[node.mesh], nodeTransform);
		}

		for (int child : node.children) {
			DrawNode(child, nodeTransform);
		}
	}

	void DrawMesh(const tinygltf::Mesh& mesh, const glm::mat4& transform) const {
		glPushMatrix();
		glMultMatrixf(glm::value_ptr(transform));

		for (const auto& primitive : mesh.primitives) {
			if (primitive.indices < 0) continue;

			// Set material properties before drawing
			if (primitive.material >= 0) {
				const auto& material = model.materials[primitive.material];
				SetMaterial(material);
			}

			// Get vertex positions
			const auto& posAccessor = model.accessors[primitive.attributes.at("POSITION")];
			const auto& posView = model.bufferViews[posAccessor.bufferView];
			const float* positions = reinterpret_cast<const float*>(
				&model.buffers[posView.buffer].data[posView.byteOffset + posAccessor.byteOffset]);

			// Get texture coordinates if available
			const float* texcoords = nullptr;
			if (primitive.attributes.find("TEXCOORD_0") != primitive.attributes.end()) {
				const auto& texAccessor = model.accessors[primitive.attributes.at("TEXCOORD_0")];
				const auto& texView = model.bufferViews[texAccessor.bufferView];
				texcoords = reinterpret_cast<const float*>(
					&model.buffers[texView.buffer].data[texView.byteOffset + texAccessor.byteOffset]);
			}

			// Get indices
			const auto& indexAccessor = model.accessors[primitive.indices];
			const auto& indexView = model.bufferViews[indexAccessor.bufferView];
			const void* indices = &model.buffers[indexView.buffer].data[indexView.byteOffset +
				indexAccessor.byteOffset];

			// Draw the primitive
			glBegin(GL_TRIANGLES);
			for (size_t i = 0; i < indexAccessor.count; i++) {
				unsigned int idx;
				switch (indexAccessor.componentType) {
				case TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT:
					idx = ((unsigned short*)indices)[i];
					break;
				case TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT:
					idx = ((unsigned int*)indices)[i];
					break;
				default:
					continue;
				}

				if (texcoords) {
					glTexCoord2f(texcoords[idx * 2], texcoords[idx * 2 + 1]);
				}
				glVertex3fv(&positions[idx * 3]);
			}
			glEnd();
		}

		glPopMatrix();
	}

	void SetMaterial(const tinygltf::Material& material) const {
		// Set default material color
		glColor4f(1.0f, 1.0f, 1.0f, 1.0f);

		if (material.pbrMetallicRoughness.baseColorTexture.index >= 0) {
			const auto& texture = model.textures[material.pbrMetallicRoughness.baseColorTexture.index];
			if (texture.source >= 0) {
				GLuint textureId = GetOrCreateTexture(texture.source);
				if (textureId != 0) {
					glEnable(GL_TEXTURE_2D);
					glBindTexture(GL_TEXTURE_2D, textureId);
				}
			}
		}
		else if (!material.pbrMetallicRoughness.baseColorFactor.empty()) {
			glColor4f(
				material.pbrMetallicRoughness.baseColorFactor[0],
				material.pbrMetallicRoughness.baseColorFactor[1],
				material.pbrMetallicRoughness.baseColorFactor[2],
				material.pbrMetallicRoughness.baseColorFactor[3]
			);
		}
	}

	GLuint GetOrCreateTexture(int sourceIndex) const {
		if (textureCache.find(sourceIndex) != textureCache.end()) {
			return textureCache.at(sourceIndex);
		}

		const auto& image = model.images[sourceIndex];
		GLuint textureId;
		glGenTextures(1, &textureId);
		glBindTexture(GL_TEXTURE_2D, textureId);

		GLenum format = GL_RGBA;
		if (image.component == 3) {
			format = GL_RGB;
		}

		glTexImage2D(GL_TEXTURE_2D, 0, format, image.width, image.height, 0, format, GL_UNSIGNED_BYTE, &image.image[0]);

		GLenum type = GL_UNSIGNED_BYTE;
		if (image.bits == 16) {
			type = GL_UNSIGNED_SHORT;
		}

		GLint internalFormat = (format == GL_RGB) ? GL_RGB8 : GL_RGBA8;

		GLint buildMipmapsResult = gluBuild2DMipmaps(GL_TEXTURE_2D, internalFormat, image.width, image.height, format, type, image.image.data());

		if (buildMipmapsResult != 0) {
			std::cerr << "Failed to build mipmaps for texture. GLU error: " << gluErrorString(buildMipmapsResult) << std::endl;
			glDeleteTextures(1, &textureId);
			return 0;
		}
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		textureCache[sourceIndex] = textureId;
		return textureId;
	}
};

GLTFModel gltfModel1;
GLTFModel carModel1;
GLTFModel coneModel;
GLTFModel nitroModel;
GLTFModel redWheelsFrontLeft1;
GLTFModel redWheelsFrontRight1;
GLTFModel redWheelsBackLeft1;
GLTFModel redWheelsBackRight1;
GLTFModel finishModel; 

int WIDTH = 1280;
int HEIGHT = 720;

GLuint tex;
char title[] = "All Star Racer";

// 3D Projection Options
GLdouble fovy = 45.0;
GLdouble aspectRatio = (GLdouble)WIDTH / (GLdouble)HEIGHT;
GLdouble zNear = 0.1;
GLdouble zFar = 10000;


struct Cone {
    float x;
    float y;
    float z;

    Cone(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {}
};

struct Nitro {
    float x;
    float y;
    float z;
    float animationPhase;

    Nitro(float _x, float _y, float _z, float _animationPhase) : x(_x), y(_y), z(_z), animationPhase(_animationPhase) {}
};

std::vector<Cone> cones = {
    Cone(-1.35632f, 1.0f, 65.1768f),
    Cone(108.473f, 1.0f, 139.522f),
    Cone(195.703f, 1.0f, 204.171f),
    Cone(278.372f, 1.0f, 257.79f),
    Cone(378.248f, 1.0f, 293.617f),
    Cone(420.81f, 1.0f, 160.304f),
    Cone(351.948f, 1.0f, 77.5647f),
    Cone(227.368f, 1.0f, -155.744f),
    Cone(230.393f, 1.0f, -241.257f),
    Cone(235.758f, 1.0f, -376.608f),
    Cone(61.4926f, 1.0f, -358.944f),
    Cone(-2.4635f, 1.0f, -263.153f),
    Cone(-7.77166f, 1.0f, -119.751f),
    Cone(-152.706f, 1.0f, -55.6917f),
    Cone(-264.162f, 1.0f, 45.1598f),
    Cone(-396.878f, 1.0f, 114.803f)
};

std::vector<Nitro> nitros = {
    //Nitro(1,1,1),
    Nitro(32.1886, 1.5, 113.886, 0.0),
    Nitro(407.525, 1.5, 153.901, 0.0),
    Nitro(228.196, 1.5, -276.122, 0.0),
    Nitro(228.196, 1.5, -276.122, 0.0)
};

Vector Eye(20, 5, 20);
Vector At(0, 0, 0);
Vector Up(0, 1, 0);

int cameraZoom = 0;

// Model Variables
Model_3DS model_house;
Model_3DS model_tree;
Model_3DS model_bugatti;
//Model_GLB model_moscow;


// Textures
GLTexture tex_ground;

enum CameraView { OUTSIDE, INSIDE_FRONT, THIRD_PERSON };
CameraView currentView = THIRD_PERSON;
float thirdPersonDistance = 3.0f;
Vector carPosition(0 ,0, 0);
float carRotation = 0; // in degrees, 0 means facing negative z-axis
//Vector(0.2, 0.61, -0.1)
Vector cameraOffset(0.2, 1.11, -0.2);
float cameraMovementSpeed = 0.05f;
float cameraYaw = 0.0f;
float cameraPitch = 0.0f;
float cameraRotationSpeed = 2.0f;
float thirdPersonYaw = 0.0f;
float thirdPersonPitch = 0.0f;
Vector thirdPersonOffset(-0.1, 2.4, -8.7); // Initial offset behind and above the car
float thirdPersonMovementSpeed = 0.1f;

//Vector carVelocity(0, 0, 0);
//float carSpeed = 0.0f; // in km/h
//float maxSpeed = 300.0f; // km/h

//float accelerationTime = 0.5f; // seconds
//float accelerationRate = maxSpeed / accelerationTime;
//bool isAccelerating = false;
float wheelRotationX = 0.0f;
float wheelRotationY = 0.0f;

float wheelRotationSpeed = 180.0f; // Degrees per second
float steeringAngle = 0.0f;
float maxSteeringAngle = 52.50f; // Maximum steering angle in degrees
float steeringSpeed = 90.0f; // Degrees per second
float deceleration = 50.0f; // Units per second^2

float carSpeed = 0.0f;
float maxSpeed = 70.0f; // Maximum speed in units per second
float acceleration = 9.0f; // Acceleration in units per second^2
//float deceleration = 3.0f; // Deceleration in units per second^2
float turnSpeed = 90.0f; // Turn speed in degrees per second
bool isAccelerating = false;
bool isBraking = false;

float cameraDistance = 8.0f; // Distance behind the car
float cameraHeight = 3.0f; // Height above the car
float cameraLookAheadDistance = 10.0f; // How far ahead of the car to look

float sunsetProgress = 0.0f;
const float sunsetDuration = 120.0f; // 2 minutes in seconds
glm::vec3 morningSkyColor(0.678f, 0.847f, 0.902f); // Bright morning sky blue
glm::vec3 noonSkyColor(0.529f, 0.808f, 0.922f); // Noon sky blue
glm::vec3 sunsetSkyColor(0.698f, 0.502f, 0.569f); // Purplish pink sunset
glm::vec3 nightSkyColor(0.1f, 0.1f, 0.2f); // Dark blue night sky
glm::vec3 currentSkyColor = morningSkyColor;

// Sun variables
glm::vec3 sunPosition(100.0f, 10.0f, 0.0f); // Start slightly above horizon
glm::vec3 sunColor(1.0f, 1.0f, 0.9f); // Bright white-yellow for morning
float sunVisibility = 1.0f; // Full visibility at start

// Modified light variables
GLfloat lightPosition[] = { 100.0f, 10.0f, 0.0f, 1.0f };
GLfloat lightAmbient[] = { 0.3f, 0.3f, 0.3f, 1.0f };
GLfloat lightDiffuse[] = { 1.0f, 1.0f, 0.9f, 1.0f };
GLfloat lightSpecular[] = { 1.0f, 1.0f, 1.0f, 1.0f };

// game over variables 
bool gameOver = false;
Vector lastCarPosition(0, 0, 0);
bool gameWon = false;
float gameTimer = 90.0f; // 90 seconds timer
float playerTime = 0.0f;
bool timerStarted = false;



//=======================================================================
// Collision Functions
//=======================================================================
struct Vertex {
    float x; // X coordinate
    float y; // Y coordinate
    float z; // Z coordinate

    // Constructor for initialization
    Vertex(float x, float y, float z) : x(x), y(y), z(z) {}

};

std::vector<Vertex> trackVertices = {
    //(226.588, -0.323614, -195.544
    {226.588000f, 0.000000f,-195.544000f},
    {225.96f, 0.0f, -226.859f},
    {227.348f, -0.0f, -259.895f}, 
    {-145.995f, 0.000000f, -56.1945f},
    {-1.67728f,0.000000f, -244.87f},
    {-1.04471f, 0.000000f, -213.832f},
    {-145.173f, 0.000000f, 111.069f},
    {370.865387f, 0.000000f, 308.835236f},
    {363.090759f, 0.000000f, 308.714722f},
    {378.469482f, 0.000000f, 308.272522f},
    {355.208588f, 0.000000f, 307.897095f},
    {385.865906f, 0.000000f, 307.036865f},
    {347.252258f, 0.000000f, 306.371368f},
    {393.000000f, 0.000000f, 305.140228f},
    {339.263458f, 0.000000f, 304.119629f},
    {399.842194f, 0.000000f, 302.586365f},
    {331.297882f, 0.000000f, 301.131958f},
    {406.318024f, 0.000000f, 299.391052f},
    {323.411987f, 0.000000f, 297.399963f},
    {412.374054f, 0.000000f, 295.566315f},
    {315.634552f, 0.000000f, 292.900299f},
    {417.960144f, 0.000000f, 291.119537f},
    {370.321350f, 0.000000f, 290.285248f},
    {364.196655f, 0.000000f, 290.189758f},
    {376.256866f, 0.000000f, 289.845856f},
    {357.907043f, 0.000000f, 289.537170f},
    {381.954926f, 0.000000f, 288.893860f},
    {351.506195f, 0.000000f, 288.308929f},
    {308.021210f, 0.000000f, 287.627594f},
    {387.381531f, 0.000000f, 287.449615f},
    {345.038605f, 0.000000f, 286.485535f},
    {422.834167f, 0.000000f, 286.245453f},
    {392.480957f, 0.000000f, 285.544647f},
    {338.534943f, 0.000000f, 284.045715f},
    {397.240021f, 0.000000f, 283.196564f},
    {300.910309f, 0.000000f, 281.807007f},
    {332.027496f, 0.000000f, 280.965332f},
    {427.902924f, 0.000000f, 280.495331f},
    {401.626648f, 0.000000f, 280.425812f},
    {295.493927f, 0.000000f, 277.651337f},
    {405.603333f, 0.000000f, 277.257385f},
    {325.572815f, 0.000000f, 277.231415f},
    {432.265411f, 0.000000f, 274.150116f},
    {409.325256f, 0.000000f, 273.533661f},
    {289.881927f, 0.000000f, 273.364929f},
    {319.200684f, 0.000000f, 272.818970f},
    {284.310730f, 0.000000f, 269.158295f},
    {413.238007f, 0.000000f, 269.098022f},
    {312.662659f, 0.000000f, 267.465607f},
    {435.791595f, 0.000000f, 267.455414f},
    {278.784027f, 0.000000f, 265.060059f},
    {416.354523f, 0.000000f, 264.570618f},
    {306.779053f, 0.000000f, 262.941895f},
    {273.298126f, 0.000000f, 261.089783f},
    {438.513306f, 0.000000f, 260.499298f},
    {418.889832f, 0.000000f, 259.766052f},
    {301.106812f, 0.000000f, 258.609161f},
    {267.892853f, 0.000000f, 257.302094f},
    {420.890259f, 0.000000f, 254.661133f},
    {295.423462f, 0.000000f, 254.318130f},
    {262.560822f, 0.000000f, 253.712814f},
    {440.490570f, 0.000000f, 253.329971f},
    {257.316864f, 0.000000f, 250.354324f},
    {289.739166f, 0.000000f, 250.103119f},
    {422.379944f, 0.000000f, 249.268829f},
    {252.170227f, 0.000000f, 247.256332f},
    {441.780945f, 0.000000f, 246.014191f},
    {284.074341f, 0.000000f, 246.003067f},
    {247.139465f, 0.000000f, 244.451279f},
    {423.383850f, 0.000000f, 243.585464f},
    {-350.777557f, 0.000000f, 242.342377f},
    {-350.777557f, 0.000000f, 242.342377f},
    {278.402130f, 0.000000f, 242.027191f},
    {242.253311f, 0.000000f, 241.971588f},
    {-343.402466f, 0.000000f, 241.797318f},
    {-357.774567f, 0.000000f, 241.684219f},
    {-364.153076f, 0.000000f, 240.875885f},
    {-336.924774f, 0.000000f, 240.195480f},
    {237.515472f, 0.000000f, 239.838593f},
    {-370.309296f, 0.000000f, 239.809860f},
    {442.447357f, 0.000000f, 238.582520f},
    {-376.243774f, 0.000000f, 238.425873f},
    {272.744720f, 0.000000f, 238.219147f},
    {232.958405f, 0.000000f, 238.080093f},
    {-331.128326f, 0.000000f, 237.685196f},
    {423.918732f, 0.000000f, 237.640701f},
    {228.597855f, 0.000000f, 236.712784f},
    {-381.962372f, 0.000000f, 236.655304f},
    {224.455154f, 0.000000f, 235.750565f},
    {112.225723f, 0.000000f, 235.229599f},
    {105.890701f, 0.000000f, 235.225891f},
    {117.640259f, 0.000000f, 235.199020f},
    {220.552551f, 0.000000f, 235.198074f},
    {98.436790f, 0.000000f, 235.180466f},
    {122.331741f, 0.000000f, 235.142471f},
    {89.630501f, 0.000000f, 235.086853f},
    {191.378403f, 0.000000f, 235.073868f},
    {196.413788f, 0.000000f, 235.072952f},
    {186.361542f, 0.000000f, 235.072021f},
    {201.487198f, 0.000000f, 235.069244f},
    {181.343765f, 0.000000f, 235.067383f},
    {126.496696f, 0.000000f, 235.066467f},
    {206.563385f, 0.000000f, 235.062744f},
    {176.358429f, 0.000000f, 235.060898f},
    {171.386978f, 0.000000f, 235.052551f},
    {166.428528f, 0.000000f, 235.042343f},
    {216.813995f, 0.000000f, 235.040512f},
    {161.480286f, 0.000000f, 235.030304f},
    {156.541290f, 0.000000f, 235.017334f},
    {151.591171f, 0.000000f, 235.002487f},
    {146.666092f, 0.000000f, 234.986740f},
    {141.745636f, 0.000000f, 234.970963f},
    {136.827972f, 0.000000f, 234.954300f},
    {79.373749f, 0.000000f, 234.938522f},
    {132.047485f, 0.000000f, 234.938522f},
    {267.103058f, 0.000000f, 234.605728f},
    {-326.037201f, 0.000000f, 234.491730f},
    {-387.450134f, 0.000000f, 234.424042f},
    {64.762764f, 0.000000f, 234.320221f},
    {50.488922f, 0.000000f, 232.217819f},
    {-392.641266f, 0.000000f, 231.677383f},
    {424.005859f, 0.000000f, 231.467896f},
    {261.482727f, 0.000000f, 231.222229f},
    {442.551178f, 0.000000f, 231.069290f},
    {-321.600647f, 0.000000f, 230.869980f},
    {36.782581f, 0.000000f, 228.783325f},
    {-397.522766f, 0.000000f, 228.332825f},
    {255.878189f, 0.000000f, 228.095505f},
    {-317.681366f, 0.000000f, 227.013718f},
    {250.277328f, 0.000000f, 225.253357f},
    {423.669373f, 0.000000f, 225.079102f},
    {-402.010315f, 0.000000f, 224.355118f},
    {23.693611f, 0.000000f, 224.155823f},
    {-350.157440f, 0.000000f, 223.746994f},
    {-350.157440f, 0.000000f, 223.746994f},
    {442.151642f, 0.000000f, 223.520828f},
    {-346.348450f, 0.000000f, 223.429047f},
    {-355.799988f, 0.000000f, 223.247360f},
    {-314.134674f, 0.000000f, 223.080505f},
    {244.690353f, 0.000000f, 222.735672f},
    {-342.900024f, 0.000000f, 222.577148f},
    {-361.434235f, 0.000000f, 222.531723f},
    {-366.650482f, 0.000000f, 221.626999f},
    {-339.833557f, 0.000000f, 221.255264f},
    {-371.429932f, 0.000000f, 220.509964f},
    {239.099701f, 0.000000f, 220.503479f},
    {239.099701f, 0.000000f, 220.503479f},
    {-406.006653f, 0.000000f, 219.764664f},
    {-336.932098f, 0.000000f, 219.446701f},
    {-310.833710f, 0.000000f, 219.196411f},
    {-375.753418f, 0.000000f, 219.168625f},
    {233.957718f, 0.000000f, 218.905350f},
    {233.957718f, 0.000000f, 218.905350f},
    {422.933472f, 0.000000f, 218.505814f},
    {11.288481f, 0.000000f, 218.481720f},
    {234.090271f, 0.000000f, 218.465027f},
    {-379.616150f, 0.000000f, 217.595520f},
    {189.536484f, 0.000000f, 217.140366f},
    {189.536484f, 0.000000f, 217.140366f},
    {189.536484f, 0.000000f, 217.140366f},
    {-334.054718f, 0.000000f, 217.108856f},
    {196.413788f, 0.000000f, 217.107910f},
    {196.413788f, 0.000000f, 217.107910f},
    {201.451965f, 0.000000f, 217.090302f},
    {201.451965f, 0.000000f, 217.090302f},
    {206.528137f, 0.000000f, 217.056000f},
    {206.528137f, 0.000000f, 217.056000f},
    {216.725937f, 0.000000f, 217.038391f},
    {216.725937f, 0.000000f, 217.038391f},
    {222.225754f, 0.000000f, 216.946625f},
    {222.225754f, 0.000000f, 216.946625f},
    {112.189575f, 0.000000f, 216.689850f},
    {105.962997f, 0.000000f, 216.686142f},
    {117.478043f, 0.000000f, 216.660187f},
    {98.581398f, 0.000000f, 216.641647f},
    {122.041588f, 0.000000f, 216.604584f},
    {89.865860f, 0.000000f, 216.548950f},
    {186.361542f, 0.000000f, 216.532257f},
    {186.361542f, 0.000000f, 216.532257f},
    {126.099014f, 0.000000f, 216.531342f},
    {184.024612f, 0.000000f, 216.530411f},
    {181.379913f, 0.000000f, 216.528549f},
    {176.394562f, 0.000000f, 216.521133f},
    {171.423141f, 0.000000f, 216.512802f},
    {166.464676f, 0.000000f, 216.502594f},
    {161.516418f, 0.000000f, 216.490555f},
    {156.577438f, 0.000000f, 216.477570f},
    {151.663483f, 0.000000f, 216.462738f},
    {146.738388f, 0.000000f, 216.447906f},
    {141.817947f, 0.000000f, 216.431213f},
    {136.900269f, 0.000000f, 216.414536f},
    {131.848190f, 0.000000f, 216.397858f},
    {79.500473f, 0.000000f, 216.397858f},
    {229.167953f, 0.000000f, 216.265305f},
    {441.305298f, 0.000000f, 215.969589f},
    {66.521629f, 0.000000f, 215.838867f},
    {-383.071014f, 0.000000f, 215.763794f},
    {186.361542f, 0.000000f, 215.605270f},
    {186.361542f, 0.000000f, 215.605270f},
    {-307.650513f, 0.000000f, 215.450470f},
    {-409.486481f, 0.000000f, 214.544800f},
    {-331.144989f, 0.000000f, 214.256500f},
    {54.114460f, 0.000000f, 214.012711f},
    {-386.112488f, 0.000000f, 213.675293f},
    {-304.487549f, 0.000000f, 211.931625f},
    {-0.400459f, 0.000000f, 211.893616f},
    {421.837677f, 0.000000f, 211.850983f},
    {-388.810089f, 0.000000f, 211.281799f},
    {42.147892f, 0.000000f, 211.014832f},
    {-328.154449f, 0.000000f, 210.945313f},
    {176.176727f, 0.000000f, 210.412292f},
    {-412.407501f, 0.000000f, 208.746506f},
    {-301.284790f, 0.000000f, 208.737213f},
    {-391.244354f, 0.000000f, 208.485092f},
    {440.053955f, 0.000000f, 208.374771f},
    {-325.016602f, 0.000000f, 207.256836f},
    {30.671045f, 0.000000f, 206.959259f},
    {-297.952271f, 0.000000f, 205.911758f},
    {-393.425476f, 0.000000f, 205.216537f},
    {420.400818f, 0.000000f, 205.057999f},
    {-11.330381f, 0.000000f, 204.520355f},
    {163.689270f, 0.000000f, 204.099503f},
    {-294.415833f, 0.000000f, 203.496033f},
    {-321.668396f, 0.000000f, 203.315262f},
    {-414.779572f, 0.000000f, 202.373459f},
    {19.716928f, 0.000000f, 201.950745f},
    {-290.537292f, 0.000000f, 201.496521f},
    {-395.377808f, 0.000000f, 201.346359f},
    {438.461304f, 0.000000f, 200.855988f},
    {-286.169342f, 0.000000f, 199.944748f},
    {-318.012268f, 0.000000f, 199.240234f},
    {-281.097778f, 0.000000f, 198.897263f},
    {-267.637939f, 0.000000f, 198.745224f},
    {-271.387604f, 0.000000f, 198.666428f},
    {-275.517334f, 0.000000f, 198.641403f},
    {-207.389328f, 0.000000f, 198.501434f},
    {-203.122391f, 0.000000f, 198.450439f},
    {-211.088928f, 0.000000f, 198.448593f},
    {418.673004f, 0.000000f, 198.245575f},
    {-198.531021f, 0.000000f, 198.236313f},
    {-193.647659f, 0.000000f, 197.794128f},
    {-188.572403f, 0.000000f, 197.062744f},
    {-397.077820f, 0.000000f, 196.787430f},
    {-21.448542f, 0.000000f, 196.500061f},
    {9.352190f, 0.000000f, 196.107941f},
    {-183.345123f, 0.000000f, 195.970749f},
    {154.083832f, 0.000000f, 195.682465f},
    {-416.616852f, 0.000000f, 195.436813f},
    {-313.915955f, 0.000000f, 195.145721f},
    {-178.047394f, 0.000000f, 194.444931f},
    {183.368286f, 0.000000f, 194.361496f},
    {183.757629f, 0.000000f, 193.492920f},
    {436.560150f, 0.000000f, 193.357574f},
    {-172.741318f, 0.000000f, 192.403702f},
    {-398.494232f, 0.000000f, 191.448898f},
    {416.683594f, 0.000000f, 191.409973f},
    {-309.276367f, 0.000000f, 191.199554f},
    {-167.520523f, 0.000000f, 189.764572f},
    {-0.366716f, 0.000000f, 189.553207f},
    {174.164246f, 0.000000f, 188.626236f},
    {-30.724997f, 0.000000f, 187.949524f},
    {-417.950867f, 0.000000f, 187.877228f},
    {-303.975861f, 0.000000f, 187.569473f},
    {-162.485123f, 0.000000f, 186.446869f},
    {147.496658f, 0.000000f, 186.430206f},
    {434.402130f, 0.000000f, 185.944458f},
    {-399.578003f, 0.000000f, 185.307602f},
    {414.474670f, 0.000000f, 184.604950f},
    {-297.957855f, 0.000000f, 184.459412f},
    {168.035004f, 0.000000f, 183.283997f},
    {-9.393534f, 0.000000f, 182.397797f},
    {-157.749161f, 0.000000f, 182.375549f},
    {-291.178802f, 0.000000f, 182.049240f},
    {-283.657196f, 0.000000f, 180.493774f},
    {-267.402466f, 0.000000f, 180.207321f},
    {-270.790619f, 0.000000f, 180.135941f},
    {-275.007477f, 0.000000f, 180.061798f},
    {-207.335556f, 0.000000f, 179.959824f},
    {-203.647995f, 0.000000f, 179.915329f},
    {-210.925781f, 0.000000f, 179.907913f},
    {-199.762070f, 0.000000f, 179.732712f},
    {-418.799927f, 0.000000f, 179.640015f},
    {-195.785294f, 0.000000f, 179.371170f},
    {-39.108856f, 0.000000f, 178.997620f},
    {-191.759384f, 0.000000f, 178.789963f},
    {432.026154f, 0.000000f, 178.627731f},
    {-400.297241f, 0.000000f, 178.336670f},
    {-187.785400f, 0.000000f, 177.957520f},
    {412.082031f, 0.000000f, 177.853699f},
    {-153.453491f, 0.000000f, 177.509781f},
    {143.056396f, 0.000000f, 177.361481f},
    {163.603058f, 0.000000f, 177.124161f},
    {-183.920776f, 0.000000f, 176.842361f},
    {-180.244339f, 0.000000f, 175.424072f},
    {-17.658739f, 0.000000f, 174.779816f},
    {-176.804306f, 0.000000f, 173.681320f},
    {-149.739044f, 0.000000f, 171.844971f},
    {-173.640503f, 0.000000f, 171.591904f},
    {429.479736f, 0.000000f, 171.444519f},
    {409.544952f, 0.000000f, 171.194229f},
    {-419.172546f, 0.000000f, 170.680664f},
    {-400.624451f, 0.000000f, 170.499908f},
    {160.110184f, 0.000000f, 170.057739f},
    {-46.563778f, 0.000000f, 169.755539f},
    {408.921021f, 0.000000f, 169.692505f},
    {139.752609f, 0.000000f, 169.229019f},
    {-170.780746f, 0.000000f, 169.127045f},
    {408.175781f, 0.000000f, 168.053589f},
    {-25.114220f, 0.000000f, 166.817917f},
    {407.321960f, 0.000000f, 166.309937f},
    {-168.222244f, 0.000000f, 166.224640f},
    {-400.513336f, 0.000000f, 165.618393f},
    {-146.721710f, 0.000000f, 165.411682f},
    {-419.037231f, 0.000000f, 164.711792f},
    {406.362518f, 0.000000f, 164.465210f},
    {426.805450f, 0.000000f, 164.420731f},
    {-165.967804f, 0.000000f, 162.785522f},
    {136.777908f, 0.000000f, 162.660370f},
    {405.311432f, 0.000000f, 162.542648f},
    {425.913696f, 0.000000f, 162.271973f},
    {156.936188f, 0.000000f, 162.259918f},
    {-400.146149f, 0.000000f, 160.756348f},
    {404.168335f, 0.000000f, 160.537567f},
    {-53.045925f, 0.000000f, 160.331772f},
    {424.933807f, 0.000000f, 160.118576f},
    {-418.595978f, 0.000000f, 158.873642f},
    {-164.040619f, 0.000000f, 158.676178f},
    {-31.697313f, 0.000000f, 158.655792f},
    {402.942963f, 0.000000f, 158.462036f},
    {-144.468201f, 0.000000f, 158.205276f},
    {133.709579f, 0.000000f, 158.124619f},
    {423.865051f, 0.000000f, 157.938293f},
    {401.652496f, 0.000000f, 156.339233f},
    {-399.532562f, 0.000000f, 156.024078f},
    {422.718292f, 0.000000f, 155.733917f},
    {130.234314f, 0.000000f, 155.322342f},
    {400.283325f, 0.000000f, 154.144135f},
    {153.256973f, 0.000000f, 154.031052f},
    {-162.513870f, 0.000000f, 153.798370f},
    {421.492828f, 0.000000f, 153.492477f},
    {124.591736f, 0.000000f, 153.316345f},
    {-417.851624f, 0.000000f, 153.124451f},
    {119.970711f, 0.000000f, 152.381943f},
    {398.862274f, 0.000000f, 151.912888f},
    {115.375626f, 0.000000f, 151.475342f},
    {-398.680664f, 0.000000f, 151.431763f},
    {420.200592f, 0.000000f, 151.226913f},
    {-58.503563f, 0.000000f, 150.837570f},
    {110.779617f, 0.000000f, 150.567825f},
    {-37.352215f, 0.000000f, 150.432480f},
    {-143.038788f, 0.000000f, 150.261917f},
    {106.182701f, 0.000000f, 149.661224f},
    {397.384644f, 0.000000f, 149.632492f},
    {418.847198f, 0.000000f, 148.934464f},
    {101.588539f, 0.000000f, 148.754639f},
    {-161.470993f, 0.000000f, 148.013046f},
    {96.991615f, 0.000000f, 147.847107f},
    {-416.810608f, 0.000000f, 147.519897f},
    {395.858826f, 0.000000f, 147.311325f},
    {-397.600647f, 0.000000f, 147.034149f},
    {92.403954f, 0.000000f, 146.941437f},
    {417.428070f, 0.000000f, 146.600311f},
    {87.809158f, 0.000000f, 146.034851f},
    {147.865601f, 0.000000f, 145.832779f},
    {83.213524f, 0.000000f, 145.127335f},
    {394.297791f, 0.000000f, 144.964188f},
    {415.968994f, 0.000000f, 144.259674f},
    {-396.304718f, 0.000000f, 142.863632f},
    {392.709930f, 0.000000f, 142.598511f},
    {-42.031921f, 0.000000f, 142.289825f},
    {-415.472015f, 0.000000f, 142.070129f},
    {414.456146f, 0.000000f, 141.884720f},
    {-142.466843f, 0.000000f, 141.511154f},
    {-62.889046f, 0.000000f, 141.360977f},
    {-161.015854f, 0.000000f, 141.284958f},
    {391.098755f, 0.000000f, 140.213364f},
    {412.908081f, 0.000000f, 139.494949f},
    {-394.812256f, 0.000000f, 138.973984f},
    {139.444855f, 0.000000f, 138.891479f},
    {46.023716f, 0.000000f, 137.794861f},
    {389.458008f, 0.000000f, 137.793930f},
    {411.329315f, 0.000000f, 137.094055f},
    {-413.839691f, 0.000000f, 136.813171f},
    {40.499985f, 0.000000f, 136.180969f},
    {387.882111f, 0.000000f, 135.476471f},
    {-393.142761f, 0.000000f, 135.395813f},
    {128.126343f, 0.000000f, 135.073227f},
    {409.721008f, 0.000000f, 134.675552f},
    {-45.684624f, 0.000000f, 134.390961f},
    {123.558151f, 0.000000f, 134.192581f},
    {35.394138f, 0.000000f, 134.126770f},
    {118.963066f, 0.000000f, 133.285995f},
    {114.369850f, 0.000000f, 132.379395f},
    {408.085785f, 0.000000f, 132.239426f},
    {-391.325043f, 0.000000f, 132.177307f},
    {-66.137398f, 0.000000f, 131.987289f},
    {-411.904053f, 0.000000f, 131.760178f},
    {30.545160f, 0.000000f, 131.632248f},
    {109.776627f, 0.000000f, 131.472809f},
    {105.182472f, 0.000000f, 130.566208f},
    {406.435760f, 0.000000f, 129.795883f},
    {100.589256f, 0.000000f, 129.659607f},
    {-389.383820f, 0.000000f, 129.338867f},
    {95.987686f, 0.000000f, 128.751175f},
    {25.967234f, 0.000000f, 128.739120f},
    {91.392616f, 0.000000f, 127.844574f},
    {404.788483f, 0.000000f, 127.368103f},
    {-409.660858f, 0.000000f, 126.946320f},
    {86.798828f, 0.000000f, 126.937981f},
    {-48.276112f, 0.000000f, 126.900902f},
    {-387.331543f, 0.000000f, 126.884216f},
    {21.665361f, 0.000000f, 125.488174f},
    {380.589478f, 0.000000f, 125.372299f},
    {-385.234650f, 0.000000f, 124.868011f},
    {403.062439f, 0.000000f, 124.830940f},
    {-383.110901f, 0.000000f, 123.270821f},
    {-68.166946f, 0.000000f, 122.781372f},
    {-407.092072f, 0.000000f, 122.391106f},
    {-380.959351f, 0.000000f, 122.066666f},
    {17.640755f, 0.000000f, 121.913704f},
    {-378.785583f, 0.000000f, 121.237007f},
    {-376.529266f, 0.000000f, 120.754044f},
    {-373.882721f, 0.000000f, 120.599236f},
    {-324.565247f, 0.000000f, 120.571426f},
    {-329.112976f, 0.000000f, 120.533424f},
    {-369.232117f, 0.000000f, 120.527863f},
    {-365.299774f, 0.000000f, 120.471321f},
    {-321.571899f, 0.000000f, 120.453697f},
    {-358.938782f, 0.000000f, 120.392525f},
    {-354.064758f, 0.000000f, 120.352661f},
    {-318.441467f, 0.000000f, 120.132965f},
    {-49.789139f, 0.000000f, 120.008751f},
    {50.039795f, 0.000000f, 119.675034f},
    {-315.144196f, 0.000000f, 119.612930f},
    {-311.684753f, 0.000000f, 118.886162f},
    {46.600212f, 0.000000f, 118.650711f},
    {-404.186890f, 0.000000f, 118.141800f},
    {13.896097f, 0.000000f, 118.052803f},
    {-308.086212f, 0.000000f, 117.946205f},
    {43.118263f, 0.000000f, 117.250038f},
    {-304.355072f, 0.000000f, 116.779121f},
    {39.765163f, 0.000000f, 115.526764f},
    {-300.527435f, 0.000000f, 115.378441f},
    {373.233856f, 0.000000f, 115.173584f},
    {395.615112f, 0.000000f, 114.510780f},
    {-400.945313f, 0.000000f, 114.259575f},
    {10.429349f, 0.000000f, 113.937904f},
    {-68.827332f, 0.000000f, 113.892479f},
    {-50.274509f, 0.000000f, 113.811836f},
    {-296.616486f, 0.000000f, 113.728409f},
    {36.536835f, 0.000000f, 113.488312f},
    {-292.658264f, 0.000000f, 111.823448f},
    {33.438564f, 0.000000f, 111.147675f},
    {-397.313354f, 0.000000f, 110.758339f},
    {-288.666656f, 0.000000f, 109.643173f},
    {7.236805f, 0.000000f, 109.595894f},
    {-68.820839f, 0.000000f, 109.383614f},
    {-50.281094f, 0.000000f, 109.383614f},
    {30.479067f, 0.000000f, 108.520592f},
    {-393.286438f, 0.000000f, 107.723381f},
    {-284.673187f, 0.000000f, 107.176460f},
    {27.665844f, 0.000000f, 105.621902f},
    {-388.878632f, 0.000000f, 105.248322f},
    {365.917145f, 0.000000f, 105.012863f},
    {-280.718658f, 0.000000f, 104.416817f},
    {388.265869f, 0.000000f, 104.320412f},
    {3.809825f, 0.000000f, 104.195267f},
    {-384.095337f, 0.000000f, 103.416603f},
    {25.011047f, 0.000000f, 102.472000f},
    {-379.010834f, 0.000000f, 102.323677f},
    {-373.945770f, 0.000000f, 102.056702f},
    {-324.609650f, 0.000000f, 102.026115f},
    {-328.959076f, 0.000000f, 101.994598f},
    {-369.503754f, 0.000000f, 101.989967f},
    {-322.904938f, 0.000000f, 101.952881f},
    {-365.552856f, 0.000000f, 101.933411f},
    {-359.137177f, 0.000000f, 101.853699f},
    {-354.155548f, 0.000000f, 101.812904f},
    {-320.839600f, 0.000000f, 101.742462f},
    {-318.500793f, 0.000000f, 101.373512f},
    {-276.824402f, 0.000000f, 101.348488f},
    {-315.943268f, 0.000000f, 100.835861f},
    {-313.195648f, 0.000000f, 100.118370f},
    {-310.311798f, 0.000000f, 99.216415f},
    {22.528481f, 0.000000f, 99.094055f},
    {0.769399f, 0.000000f, 98.559181f},
    {-307.311127f, 0.000000f, 98.117935f},
    {-273.027435f, 0.000000f, 97.960350f},
    {-304.237244f, 0.000000f, 96.821083f},
    {-301.110535f, 0.000000f, 95.315651f},
    {358.631042f, 0.000000f, 94.874405f},
    {19.821770f, 0.000000f, 94.826202f},
    {-269.357513f, 0.000000f, 94.242203f},
    {380.948212f, 0.000000f, 94.159698f},
    {-297.973572f, 0.000000f, 93.600723f},
    {-1.885307f, 0.000000f, 92.728424f},
    {-294.852448f, 0.000000f, 91.672218f},
    {17.386667f, 0.000000f, 90.313995f},
    {-265.851624f, 0.000000f, 90.185333f},
    {-291.762787f, 0.000000f, 89.516235f},
    {-288.739868f, 0.000000f, 87.133133f},
    {-4.151884f, 0.000000f, 86.741013f},
    {-262.568237f, 0.000000f, 85.828026f},
    {15.240507f, 0.000000f, 85.601097f},
    {351.432953f, 0.000000f, 84.827896f},
    {-285.804108f, 0.000000f, 84.513458f},
    {373.703003f, 0.000000f, 84.077774f},
    {-282.980499f, 0.000000f, 81.651756f},
    {-259.795624f, 0.000000f, 81.205048f},
    {13.398120f, 0.000000f, 80.735252f},
    {-6.025510f, 0.000000f, 80.637817f},
    {-280.289459f, 0.000000f, 78.537354f},
    {-257.868408f, 0.000000f, 76.202003f},
    {11.871278f, 0.000000f, 75.761864f},
    {-277.730988f, 0.000000f, 75.114548f},
    {344.313690f, 0.000000f, 74.854530f},
    {-7.500440f, 0.000000f, 74.454727f},
    {366.510406f, 0.000000f, 74.039986f},
    {-276.553680f, 0.000000f, 73.121346f},
    {-256.683716f, 0.000000f, 71.109222f},
    {-275.654541f, 0.000000f, 70.812027f},
    {10.671201f, 0.000000f, 70.730637f},
    {-8.568700f, 0.000000f, 68.228516f},
    {-274.980621f, 0.000000f, 67.954124f},
    {-68.825752f, 0.000000f, 66.857033f},
    {-50.276180f, 0.000000f, 66.798546f},
    {-256.063568f, 0.000000f, 65.981682f},
    {-142.464981f, 0.000000f, 65.892509f},
    {-161.017715f, 0.000000f, 65.865807f},
    {9.806599f, 0.000000f, 65.690239f},
    {337.297424f, 0.000000f, 64.980911f},
    {-274.563477f, 0.000000f, 64.550323f},
    {359.414337f, 0.000000f, 64.099068f},
    {-9.220280f, 0.000000f, 61.995266f},
    {-255.855011f, 0.000000f, 60.820217f},
    {9.284428f, 0.000000f, 60.690529f},
    {-274.402161f, 0.000000f, 60.657249f},
    {-141.754898f, 0.000000f, 56.491646f},
    {-274.467041f, 0.000000f, 56.313854f},
    {-9.438214f, 0.000000f, 55.805771f},
    {9.104499f, 0.000000f, 55.766464f},
    {-255.936584f, 0.000000f, 55.643730f},
    {330.394989f, 0.000000f, 55.213982f},
    {-69.618050f, 0.000000f, 54.990948f},
    {352.423920f, 0.000000f, 54.262337f},
    {-160.122223f, 0.000000f, 53.465313f},
    {-51.209564f, 0.000000f, 52.334755f},
    {-274.709930f, 0.000000f, 51.603271f},
    {-256.207275f, 0.000000f, 50.426456f},
    {-139.649719f, 0.000000f, 48.323772f},
    {-275.065887f, 0.000000f, 46.573063f},
    {323.647430f, 0.000000f, 45.604919f},
    {-71.844948f, 0.000000f, 45.289925f},
    {-256.578979f, 0.000000f, 45.178783f},
    {345.565155f, 0.000000f, 44.556591f},
    {-157.171631f, 0.000000f, 42.032864f},
    {-275.464508f, 0.000000f, 41.251411f},
    {-136.345001f, 0.000000f, 41.219711f},
    {-256.971100f, 0.000000f, 39.929806f},
    {-54.143475f, 0.000000f, 39.521378f},
    {-75.201012f, 0.000000f, 37.539665f},
    {317.039856f, 0.000000f, 36.123409f},
    {-275.825073f, 0.000000f, 35.712940f},
    {-132.032669f, 0.000000f, 35.153782f},
    {338.829651f, 0.000000f, 34.964584f},
    {-257.314087f, 0.000000f, 34.662849f},
    {-152.430084f, 0.000000f, 31.845083f},
    {-79.407776f, 0.000000f, 31.537323f},
    {-126.886024f, 0.000000f, 30.126173f},
    {-276.069824f, 0.000000f, 29.940958f},
    {-257.533783f, 0.000000f, 29.452066f},
    {-58.924324f, 0.000000f, 28.465010f},
    {-84.274002f, 0.000000f, 27.051632f},
    {310.606567f, 0.000000f, 26.810616f},
    {-121.086800f, 0.000000f, 26.173960f},
    {332.269379f, 0.000000f, 25.550932f},
    {-257.568085f, 0.000000f, 24.290136f},
    {-276.110596f, 0.000000f, 24.000360f},
    {-89.698906f, 0.000000f, 23.890789f},
    {-114.839828f, 0.000000f, 23.345629f},
    {-146.162735f, 0.000000f, 23.035460f},
    {-95.605766f, 0.000000f, 21.955610f},
    {-108.363899f, 0.000000f, 21.685392f},
    {-101.883324f, 0.000000f, 21.219952f},
    {-65.371429f, 0.000000f, 19.260950f},
    {-257.354858f, 0.000000f, 19.215063f},
    {-275.857513f, 0.000000f, 17.910978f},
    {304.363312f, 0.000000f, 17.682289f},
    {325.884277f, 0.000000f, 16.308216f},
    {-138.657837f, 0.000000f, 15.711329f},
    {-256.839447f, 0.000000f, 14.255957f},
    {-73.217262f, 0.000000f, 12.032763f},
    {-275.215118f, 0.000000f, 11.701180f},
    {-130.190750f, 0.000000f, 9.943333f},
    {-255.970871f, 0.000000f, 9.441555f},
    {298.330505f, 0.000000f, 8.756418f},
    {319.692932f, 0.000000f, 7.254605f},
    {-82.103363f, 0.000000f, 6.864622f},
    {-121.016350f, 0.000000f, 5.790428f},
    {-274.083282f, 0.000000f, 5.399889f},
    {-254.700897f, 0.000000f, 4.782330f},
    {-91.647713f, 0.000000f, 3.748089f},
    {-111.375679f, 0.000000f, 3.316391f},
    {-101.502342f, 0.000000f, 2.601776f},
    {-252.967438f, 0.000000f, 0.232767f},
    {292.509918f, 0.000000f, 0.030498f},
    {9.118403f, 0.000000f, -0.478604f},
    {-9.421250f, 0.000000f, -0.493343f},
    {-272.357239f, 0.000000f, -0.945713f},
    {313.711975f, 0.000000f, -1.593770f},
    {-250.838150f, 0.000000f, -4.366575f},
    {-269.949860f, 0.000000f, -7.232543f},
    {286.937805f, 0.000000f, -8.453850f},
    {-248.562378f, 0.000000f, -8.835583f},
    {307.971161f, 0.000000f, -10.200479f},
    {-267.520203f, 0.000000f, -12.461217f},
    {-246.144806f, 0.000000f, -13.133283f},
    {281.617828f, 0.000000f, -16.698292f},
    {-243.580765f, 0.000000f, -17.230013f},
    {-264.914429f, 0.000000f, -17.580877f},
    {302.472260f, 0.000000f, -18.573309f},
    {-240.862839f, 0.000000f, -21.104635f},
    {-262.099182f, 0.000000f, -22.586981f},
    {276.582428f, 0.000000f, -24.666677f},
    {-237.972488f, 0.000000f, -24.753166f},
    {297.244080f, 0.000000f, -26.676386f},
    {-259.047546f, 0.000000f, -27.463215f},
    {-234.914352f, 0.000000f, -28.145199f},
    {-231.667114f, 0.000000f, -31.278233f},
    {-255.736343f, 0.000000f, -32.185287f},
    {271.753754f, 0.000000f, -32.310062f},
    {-228.220581f, 0.000000f, -34.139381f},
    {292.291168f, 0.000000f, -34.512215f},
    {-252.152603f, 0.000000f, -36.711399f},
    {-224.557129f, 0.000000f, -36.721226f},
    {-220.653595f, 0.000000f, -39.015148f},
    {266.889862f, 0.000000f, -39.891338f},
    {-216.476578f, 0.000000f, -41.015034f},
    {-248.263901f, 0.000000f, -41.026245f},
    {287.381836f, 0.000000f, -42.283985f},
    {-211.997360f, 0.000000f, -42.706318f},
    {-207.188171f, 0.000000f, -44.069733f},
    {-202.003540f, 0.000000f, -45.085617f},
    {-244.057220f, 0.000000f, -45.086731f},
    {-196.422134f, 0.000000f, -45.725056f},
    {-89.716156f, 0.000000f, -45.958935f},
    {-190.396729f, 0.000000f, -45.962086f},
    {-115.345963f, 0.000000f, -45.963753f},
    {-95.854202f, 0.000000f, -45.963753f},
    {-106.326378f, 0.000000f, -45.963753f},
    {-78.403023f, 0.000000f, -46.695892f},
    {262.037079f, 0.000000f, -47.413563f},
    {-67.645699f, 0.000000f, -48.800060f},
    {-239.514984f, 0.000000f, -48.860039f},
    {282.479950f, 0.000000f, -49.925327f},
    {-57.529114f, 0.000000f, -52.180321f},
    {-234.624207f, 0.000000f, -52.307873f},
    {257.220459f, 0.000000f, -54.912987f},
    {-229.376541f, 0.000000f, -55.393257f},
    {9.173652f, 0.000000f, -56.467083f},
    {-9.366002f, 0.000000f, -56.487473f},
    {-48.100170f, 0.000000f, -56.741192f},
    {277.616943f, 0.000000f, -57.462391f},
    {-223.773819f, 0.000000f, -58.076519f},
    {-217.816071f, 0.000000f, -60.326687f},
    {-211.500519f, 0.000000f, -62.117260f},
    {-39.393997f, 0.000000f, -62.374683f},
    {252.488174f, 0.000000f, -62.393871f},
    {-204.839172f, 0.000000f, -63.422085f},
    {-197.826508f, 0.000000f, -64.224762f},
    {-115.345963f, 0.000000f, -64.503510f},
    {-106.326378f, 0.000000f, -64.503510f},
    {-95.854202f, 0.000000f, -64.503510f},
    {-190.478287f, 0.000000f, -64.505180f},
    {-89.856224f, 0.000000f, -64.508331f},
    {272.848541f, 0.000000f, -64.887932f},
    {-80.797615f, 0.000000f, -65.118195f},
    {-72.386032f, 0.000000f, -66.763596f},
    {-31.428579f, 0.000000f, -68.968994f},
    {-64.541214f, 0.000000f, -69.383911f},
    {247.877350f, 0.000000f, -69.875496f},
    {268.206177f, 0.000000f, -72.226616f},
    {-57.220707f, 0.000000f, -72.923248f},
    {-24.208553f, 0.000000f, -76.414009f},
    {-50.394276f, 0.000000f, -77.337929f},
    {243.423172f, 0.000000f, -77.384651f},
    {263.731598f, 0.000000f, -79.488258f},
    {-44.048492f, 0.000000f, -82.588394f},
    {-17.725389f, 0.000000f, -84.610062f},
    {239.176651f, 0.000000f, -84.923004f},
    {259.468384f, 0.000000f, -86.675011f},
    {-38.183353f, 0.000000f, -88.632904f},
    {235.171127f, 0.000000f, -92.521523f},
    {-11.968148f, 0.000000f, -93.462608f},
    {255.447128f, 0.000000f, -93.813934f},
    {-32.812107f, 0.000000f, -95.419472f},
    {-9.266722f, 0.000000f, -97.205780f},
    {-9.266722f, 0.000000f, -97.205780f},
    {-9.907919f, 0.000000f, -97.241928f},
    {-9.846459f, 0.000000f, -97.355026f},
    {-9.846459f, 0.000000f, -97.355026f},
    {-8.994373f, 0.000000f, -99.154305f},
    {-8.994373f, 0.000000f, -99.154305f},
    {-8.994373f, 0.000000f, -99.154305f},
    {231.454834f, 0.000000f, -100.191605f},
    {251.710449f, 0.000000f, -100.904457f},
    {-6.923205f, 0.000000f, -102.885429f},
    {-6.923205f, 0.000000f, -102.885429f},
    {-27.950430f, 0.000000f, -102.891922f},
    {228.068558f, 0.000000f, -107.961617f},
    {248.291702f, 0.000000f, -107.962540f},
    {-23.616488f, 0.000000f, -110.984520f},
    {-2.574615f, 0.000000f, -112.806053f},
    {-2.574615f, 0.000000f, -112.806053f},
    {9.234277f, 0.000000f, -113.000717f},
    {245.229874f, 0.000000f, -114.989113f},
    {225.061401f, 0.000000f, -115.842865f},
    {-19.830763f, 0.000000f, -119.617561f},
    {242.554581f, 0.000000f, -122.003624f},
    {1.085039f, 0.000000f, -123.141045f},
    {1.085039f, 0.000000f, -123.141045f},
    {222.481598f, 0.000000f, -123.852966f},
    {-16.605589f, 0.000000f, -128.724289f},
    {240.296448f, 0.000000f, -129.015366f},
    {220.381973f, 0.000000f, -131.993774f},
    {4.065210f, 0.000000f, -133.820862f},
    {4.065210f, 0.000000f, -133.820862f},
    {238.482330f, 0.000000f, -136.052124f},
    {-13.954867f, 0.000000f, -138.221268f},
    {218.809814f, 0.000000f, -140.291245f},
    {237.144684f, 0.000000f, -143.117630f},
    {6.371740f, 0.000000f, -144.775070f},
    {6.371740f, 0.000000f, -144.775070f},
    {-11.889355f, 0.000000f, -148.027878f},
    {217.817001f, 0.000000f, -148.750000f},
    {236.310394f, 0.000000f, -150.235962f},
    {8.007966f, 0.000000f, -155.930435f},
    {8.007966f, 0.000000f, -155.930435f},
    {217.460098f, 0.000000f, -157.357071f},
    {236.003571f, 0.000000f, -157.447922f},
    {-10.416835f, 0.000000f, -158.066223f},
    {217.461960f, 0.000000f, -165.889084f},
    {236.001709f, 0.000000f, -165.889084f},
    {8.975463f, 0.000000f, -167.218384f},
    {8.975463f, 0.000000f, -167.218384f},
    {8.975463f, 0.000000f, -167.218384f},
    {8.975463f, 0.000000f, -167.218384f},
    {-9.543521f, 0.000000f, -168.253830f},
    {-9.543521f, 0.000000f, -168.253830f},
    {9.270708f, 0.000000f, -178.529480f},
    {-9.270708f, 0.000000f, -178.546173f},
    {9.284057f, 0.000000f, -274.412445f},
    {-9.284057f, 0.000000f, -274.595062f},
    {9.715291f, 0.000000f, -277.962799f},
    {10.968115f, 0.000000f, -281.888611f},
    {-8.472294f, 0.000000f, -282.002625f},
    {13.159420f, 0.000000f, -286.265839f},
    {-6.199043f, 0.000000f, -289.033813f},
    {16.247307f, 0.000000f, -290.987000f},
    {236.001709f, 0.000000f, -293.192291f},
    {217.461960f, 0.000000f, -293.192291f},
    {-2.885712f, 0.000000f, -295.614502f},
    {20.125174f, 0.000000f, -295.961212f},
    {24.645073f, 0.000000f, -301.114319f},
    {236.002640f, 0.000000f, -301.660309f},
    {217.461044f, 0.000000f, -301.696472f},
    {1.205362f, 0.000000f, -301.851257f},
    {29.647282f, 0.000000f, -306.398163f},
    {5.876266f, 0.000000f, -307.834991f},
    {236.197311f, 0.000000f, -308.667419f},
    {217.679810f, 0.000000f, -309.700104f},
    {34.971802f, 0.000000f, -311.784882f},
    {10.970525f, 0.000000f, -313.638947f},
    {236.767395f, 0.000000f, -315.705109f},
    {40.463737f, 0.000000f, -317.264313f},
    {218.323151f, 0.000000f, -317.629639f},
    {16.343529f, 0.000000f, -319.312103f},
    {237.658234f, 0.000000f, -322.795624f},
    {45.971062f, 0.000000f, -322.834656f},
    {21.850761f, 0.000000f, -324.883209f},
    {219.308517f, 0.000000f, -325.461670f},
    {51.344345f, 0.000000f, -328.508667f},
    {238.817902f, 0.000000f, -329.952911f},
    {27.342791f, 0.000000f, -330.362671f},
    {220.559952f, 0.000000f, -333.183472f},
    {56.434067f, 0.000000f, -334.307892f},
    {32.667313f, 0.000000f, -335.748444f},
    {240.183365f, 0.000000f, -337.167633f},
    {61.108398f, 0.000000f, -340.294464f},
    {222.003281f, 0.000000f, -340.804321f},
    {37.669243f, 0.000000f, -341.032257f},
    {241.697128f, 0.000000f, -344.441742f},
    {42.193684f, 0.000000f, -346.190948f},
    {65.197891f, 0.000000f, -346.528473f},
    {223.567093f, 0.000000f, -348.322205f},
    {46.068024f, 0.000000f, -351.161469f},
    {243.293396f, 0.000000f, -351.774200f},
    {68.512154f, 0.000000f, -353.110077f},
    {225.181915f, 0.000000f, -355.738098f},
    {49.157581f, 0.000000f, -355.885406f},
    {244.905426f, 0.000000f, -359.152100f},
    {70.786705f, 0.000000f, -360.143982f},
    {51.347961f, 0.000000f, -360.261719f},
    {226.782822f, 0.000000f, -363.063995f},
    {52.599396f, 0.000000f, -364.184692f},
    {246.469254f, 0.000000f, -366.594971f},
    {71.597076f, 0.000000f, -367.520935f},
    {53.032021f, 0.000000f, -367.765747f},
    {228.300308f, 0.000000f, -370.283386f},
    {71.612556f, 0.000000f, -373.384155f},
    {53.072990f, 0.000000f, -373.461151f},
    {247.915344f, 0.000000f, -374.094208f},
    {229.671310f, 0.000000f, -377.401703f},
    {71.643890f, 0.000000f, -379.161133f},
    {53.104607f, 0.000000f, -379.305725f},
    {249.174194f, 0.000000f, -381.664917f},
    {230.834686f, 0.000000f, -384.406006f},
    {71.712204f, 0.000000f, -384.903900f},
    {53.174774f, 0.000000f, -385.219910f},
    {250.168869f, 0.000000f, -389.303314f},
    {71.850418f, 0.000000f, -390.593658f},
    {53.319668f, 0.000000f, -391.195374f},
    {231.732010f, 0.000000f, -391.299103f},
    {72.090416f, 0.000000f, -396.219635f},
    {250.822388f, 0.000000f, -397.000092f},
    {53.575977f, 0.000000f, -397.214294f},
    {232.307663f, 0.000000f, -398.089294f},
    {72.462883f, 0.000000f, -401.761200f},
    {53.982368f, 0.000000f, -403.269287f},
    {251.057846f, 0.000000f, -404.767303f},
    {232.507889f, 0.000000f, -404.767303f},
    {72.997475f, 0.000000f, -407.207214f},
    {54.577866f, 0.000000f, -409.341980f},
    {232.282639f, 0.000000f, -411.324799f},
    {73.722931f, 0.000000f, -412.544739f},
    {250.790863f, 0.000000f, -412.612396f},
    {55.402794f, 0.000000f, -415.419312f},
    {74.665306f, 0.000000f, -417.755310f},
    {231.584625f, 0.000000f, -417.778595f},
    {249.936188f, 0.000000f, -420.516815f},
    {56.499878f, 0.000000f, -421.491180f},
    {75.850372f, 0.000000f, -422.825958f},
    {230.484283f, 0.000000f, -423.532288f},
    {57.912422f, 0.000000f, -427.541534f},
    {77.305740f, 0.000000f, -427.757599f},
    {228.174225f, 0.000000f, -428.872772f},
    {248.291702f, 0.000000f, -429.079498f},
    {79.053024f, 0.000000f, -432.530609f},
    {59.681858f, 0.000000f, -433.542877f},
    {225.218063f, 0.000000f, -434.581085f},
    {244.936935f, 0.000000f, -436.818909f},
    {81.117607f, 0.000000f, -437.142334f},
    {61.855362f, 0.000000f, -439.485748f},
    {221.903168f, 0.000000f, -440.058655f},
    {83.535927f, 0.000000f, -441.609589f},
    {241.391220f, 0.000000f, -443.665680f},
    {218.264740f, 0.000000f, -445.279449f},
    {64.476517f, 0.000000f, -445.345337f},
    {86.339691f, 0.000000f, -445.929352f},
    {89.565239f, 0.000000f, -450.102570f},
    {89.565239f, 0.000000f, -450.102570f},
    {237.445038f, 0.000000f, -450.184204f},
    {214.346359f, 0.000000f, -450.214722f},
    {67.577843f, 0.000000f, -451.075897f},
    {93.270683f, 0.000000f, -454.151733f},
    {210.176773f, 0.000000f, -454.855225f},
    {233.138260f, 0.000000f, -456.362579f},
    {71.196617f, 0.000000f, -456.652679f},
    {96.465080f, 0.000000f, -457.178345f},
    {205.809738f, 0.000000f, -459.162933f},
    {99.845810f, 0.000000f, -460.030609f},
    {75.365273f, 0.000000f, -462.047821f},
    {75.365273f, 0.000000f, -462.047821f},
    {228.506088f, 0.000000f, -462.196045f},
    {103.400803f, 0.000000f, -462.706818f},
    {201.289734f, 0.000000f, -463.117462f},
    {107.103188f, 0.000000f, -465.197632f},
    {196.625153f, 0.000000f, -466.725281f},
    {80.094490f, 0.000000f, -467.210205f},
    {110.920525f, 0.000000f, -467.491943f},
    {223.597687f, 0.000000f, -467.658783f},
    {114.874130f, 0.000000f, -469.612061f},
    {191.890091f, 0.000000f, -469.941925f},
    {84.109367f, 0.000000f, -471.010864f},
    {118.904663f, 0.000000f, -471.533569f},
    {187.135574f, 0.000000f, -472.748962f},
    {218.435287f, 0.000000f, -472.749817f},
    {123.009369f, 0.000000f, -473.265198f},
    {88.300186f, 0.000000f, -474.545471f},
    {127.200279f, 0.000000f, -474.818939f},
    {182.387543f, 0.000000f, -475.142334f},
    {131.414368f, 0.000000f, -476.175934f},
    {177.715530f, 0.000000f, -477.096436f},
    {135.649765f, 0.000000f, -477.343933f},
    {213.052277f, 0.000000f, -477.457977f},
    {92.644600f, 0.000000f, -477.815887f},
    {139.906494f, 0.000000f, -478.328400f},
    {173.145493f, 0.000000f, -478.611115f},
    {144.149307f, 0.000000f, -479.125610f},
    {168.746933f, 0.000000f, -479.672546f},
    {148.327240f, 0.000000f, -479.730927f},
    {152.474594f, 0.000000f, -480.155579f},
    {164.579193f, 0.000000f, -480.280731f},
    {156.557037f, 0.000000f, -480.397522f},
    {160.573669f, 0.000000f, -480.456879f},
    {97.133446f, 0.000000f, -480.834991f},
    {207.517242f, 0.000000f, -481.738800f},
    {101.762825f, 0.000000f, -483.618805f},
    {201.833878f, 0.000000f, -485.600616f},
    {106.478401f, 0.000000f, -486.147552f},
    {111.301514f, 0.000000f, -488.447510f},
    {196.028152f, 0.000000f, -489.028625f},
    {116.201576f, 0.000000f, -490.514679f},
    {190.150131f, 0.000000f, -491.991394f},
    {121.128517f, 0.000000f, -492.340759f},
    {126.112923f, 0.000000f, -493.945465f},
    {184.210007f, 0.000000f, -494.475677f},
    {131.117722f, 0.000000f, -495.325745f},
    {178.257813f, 0.000000f, -496.449158f},
    {136.111404f, 0.000000f, -496.479736f},
    {141.090256f, 0.000000f, -497.415100f},
    {172.300064f, 0.000000f, -497.888763f},
    {146.072815f, 0.000000f, -498.137299f},
    {150.985840f, 0.000000f, -498.639648f},
    {166.356232f, 0.000000f, -498.759186f},
    {155.831207f, 0.000000f, -498.928009f},
    {160.573669f, 0.000000f, -499.004852f},
    { 0, -0.264776, 23.2566 }, 
    { 0.316699, -0.304001, -31.0523 }, 
    { -242.272, -0.451099, 191.192 }, 
    { -166.405, -0.833553, -56.9069 }
};

bool isPointInTrack(const std::vector<Vertex>& trackVertices, const Vector& carPosition, float threshold = 25.0f) {
    // Loop through each vertex in the track
    for (const auto& vertex : trackVertices) {
        // Create a Vector for the track vertex
        Vector trackVertex(vertex.x, vertex.y, vertex.z);

        // Check the distance between the car and the vertex
        float distance = carPosition.distanceToNoY(trackVertex);

        // If the distance is smaller than the threshold, the car is close enough to this vertex
        if (distance <= threshold) {
            std::cout << "Car is near vertex: ";
            trackVertex.print();
            return true; // Car is close to this vertex
        }
    }

    return false; // Car is not close to any vertex
}

//=======================================================================
// Car Motion Functions
//=======================================================================
bool gravityEnabled = false;

bool hasPassedFinishLine() {
    float finishX = 111.845f;
    float finishZ = 225.249f;
    float threshold = 10.0f;

    return (abs(carPosition.x - finishX) < threshold &&
        abs(carPosition.z - finishZ) < threshold);
}

void updateCarPosition(float deltaTime) {
    float radians = carRotation * M_PI / 180.0;
    if (gravityEnabled) {
        carPosition.y -= 9.8065 * deltaTime;
        std::cout << "Car position when gravity enabled: ";
        carPosition.print();

        if (carPosition.y < -3.0f) {
            gameOver = true;
            lastCarPosition = carPosition;
        }
    }

    carPosition.x += sin(radians) * carSpeed * deltaTime;
    carPosition.z += cos(radians) * carSpeed * deltaTime;

    if (isPointInTrack(trackVertices, carPosition)) {
        std::cout << "Car is within the track boundaries." << std::endl;
        gravityEnabled = false;
    }
    else {
        gravityEnabled = true;
    }

    wheelRotationX += carSpeed * 360.0f * deltaTime;

    if (!gameWon && hasPassedFinishLine()) {
        gameWon = true;
        playerTime = 90.0f - gameTimer; // Calculate player's time
    }

    // Update game timer
    if (!gameWon && !gameOver && timerStarted) {
        gameTimer -= deltaTime;
        if (gameTimer <= 0) {
            gameOver = true;
            lastCarPosition = carPosition;
        }
    }
}

void handleCarControls(float deltaTime) {
	// Accelerate
	if (isAccelerating) {
		carSpeed += acceleration * deltaTime;
		if (carSpeed > maxSpeed) carSpeed = maxSpeed;
	}
	// Brake
	else if (isBraking) {
		carSpeed -= deceleration * deltaTime;
		if (carSpeed < 0) carSpeed = 0;
	}
	// Coast (slow down gradually)
	else {
		carSpeed -= deceleration * 0.5f * deltaTime; // Adjust this factor for desired coasting behavior
		if (carSpeed < 0) carSpeed = 0;
	}

	// Turn left
	if (wheelRotationY > 0) {
		carRotation += turnSpeed * deltaTime * (carSpeed / maxSpeed);
	}
	// Turn right
	else if (wheelRotationY < 0) {
		carRotation -= turnSpeed * deltaTime * (carSpeed / maxSpeed);
	}

	// Normalize rotation to 0-360 degrees
	while (carRotation >= 360.0f) carRotation -= 360.0f;
	while (carRotation < 0.0f) carRotation += 360.0f;
}



//=======================================================================
// Lighting Configuration Function
//=======================================================================
void InitLightSource() {
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmbient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpecular);
    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition);
}

void updateNitroAnimation() {
    for (auto& nitro : nitros) {
        nitro.animationPhase += 0.5f;
        if (nitro.animationPhase > 360.0f) {
            nitro.animationPhase -= 360.0f;
        }
        nitro.y = nitro.y + sin(nitro.animationPhase) * 0.08f;
    }
}

void updateSunPosition(float deltaTime) {
    if (sunsetProgress < 1.0f) {
        sunsetProgress += deltaTime / sunsetDuration;
        if (sunsetProgress > 1.0f) {
            sunsetProgress = 1.0f; // Clamp to 1.0 to stop the sunset
        }

        float angle = sunsetProgress * M_PI;

        // Update sun position (arc from east to west)
        sunPosition.x = 100.0f * cosf(angle);
        sunPosition.y = 100.0f * sinf(angle) + 10.0f; // Add 10 to keep sun above horizon initially

        // Update light position to match sun
        lightPosition[0] = sunPosition.x;
        lightPosition[1] = sunPosition.y;
        lightPosition[2] = sunPosition.z;
        lightPosition[3] = 1.0f; // Ensure it's a positional light
        glLightfv(GL_LIGHT0, GL_POSITION, lightPosition);

        // Update light color and intensity to simulate sunset
        float intensity = 1.0f - 0.7f * sunsetProgress; // Gradually reduce intensity
        float r = 1.0f;
        float g = 1.0f - 0.4f * sunsetProgress;
        float b = 0.9f - 0.6f * sunsetProgress;

        lightDiffuse[0] = r * intensity;
        lightDiffuse[1] = g * intensity;
        lightDiffuse[2] = b * intensity;
        glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiffuse);

        lightAmbient[0] = r * 0.3f * intensity;
        lightAmbient[1] = g * 0.3f * intensity;
        lightAmbient[2] = b * 0.3f * intensity;
        glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmbient);

        // Update sky color
        glm::vec3 midSkyColor;
        if (sunsetProgress < 0.5f) {
            // First half: transition from morning to noon
            midSkyColor = glm::mix(morningSkyColor, noonSkyColor, sunsetProgress * 2);
        }
        else {
            // Second half: transition from noon to sunset, then to night
            float t = (sunsetProgress - 0.5f) * 2;
            midSkyColor = glm::mix(noonSkyColor, sunsetSkyColor, t);
            midSkyColor = glm::mix(midSkyColor, nightSkyColor, std::max(0.0f, t - 0.5f) * 2);
        }
        currentSkyColor = midSkyColor;

        // Update sun color and visibility
        sunColor = glm::vec3(r, g, b);
        sunVisibility = std::max(0.0f, 1.0f - (sunsetProgress - 0.8f) * 5.0f); // Sun starts to disappear at 80% of sunset
    }
}

//=======================================================================
// Camera Function
//=======================================================================
void updateCamera()
{
    if (gameOver) {
        Eye = Vector(lastCarPosition.x, lastCarPosition.y + 5.0f, lastCarPosition.z + 10.0f);
        At = Vector(carPosition.x, 0, carPosition.z);
	}
    else if (gameWon) {
        // Position the camera in front of the car
        float radians = carRotation * M_PI / 180.0;
        Eye = Vector(
            carPosition.x + sin(radians) * 10.0f,
            carPosition.y + 3.0f,
            carPosition.z + cos(radians) * 10.0f
        );
        At = Vector(carPosition.x, carPosition.y, carPosition.z);
    }
    else
    if (currentView == INSIDE_FRONT)
    {
        float carRadians = -(carRotation * M_PI / 180.0);
        float yawRadians = cameraYaw * M_PI / 180.0;
        float pitchRadians = cameraPitch * M_PI / 180.0;

        // Calculate the rotated camera offset using car's rotation
        Vector rotatedCameraOffset(
            cameraOffset.x * cos(carRadians) - cameraOffset.z * sin(carRadians),
            cameraOffset.y,
            cameraOffset.x * sin(carRadians) + cameraOffset.z * cos(carRadians)
        );

        // Apply yaw and pitch rotations to the look-at vector
        Vector lookAt(0.0348995, 0, 0.999391);

        // Apply yaw rotation
        Vector yawLookAt(
            lookAt.x * cos(yawRadians) - lookAt.z * sin(yawRadians),
            lookAt.y,
            lookAt.x * sin(yawRadians) + lookAt.z * cos(yawRadians)
        );

        // Apply pitch rotation
        Vector pitchLookAt(
            yawLookAt.x,
            yawLookAt.y * cos(pitchRadians) - yawLookAt.z * sin(pitchRadians),
            yawLookAt.y * sin(pitchRadians) + yawLookAt.z * cos(pitchRadians)
        );

        Eye = Vector(
            carPosition.x + rotatedCameraOffset.x,
            carPosition.y + rotatedCameraOffset.y,
            carPosition.z + rotatedCameraOffset.z
        );

        At = Vector(
            Eye.x + pitchLookAt.x + sin(-carRadians) * cameraLookAheadDistance,
            Eye.y + pitchLookAt.y,
            Eye.z + pitchLookAt.z + cos(-carRadians) * cameraLookAheadDistance
        );

        Up = Vector(0, 1, 0);
    }

    else if (currentView == THIRD_PERSON)
	{
		float radians = carRotation * M_PI / 180.0;
		
		// Calculate camera position
		Eye.x = carPosition.x - sin(radians) * cameraDistance;
		Eye.y = carPosition.y + cameraHeight;
		Eye.z = carPosition.z - cos(radians) * cameraDistance;

		// Calculate look-at point
		At.x = carPosition.x + sin(radians) * cameraLookAheadDistance;
		At.y = carPosition.y + 1.0f; // Look slightly above the car
		At.z = carPosition.z + cos(radians) * cameraLookAheadDistance;

		Up = Vector(0, 1, 0); // Keep the up vector vertical


	}
	else
	{
		Eye = Vector(20, 5, 20);
		At = Vector(0, 0, 0);
		Up = Vector(0, 1, 0);
	}
	/*thirdPersonOffset.print();*/
	glLoadIdentity();
	gluLookAt(Eye.x, Eye.y, Eye.z, At.x, At.y, At.z, Up.x, Up.y, Up.z);
}

void drawGameOverText() {

    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();
    gluOrtho2D(0, WIDTH, 0, HEIGHT);

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();

    glColor3f(1.0f, 0.0f, 0.0f);  // Red color for text
    glRasterPos2i(WIDTH / 2 - 50, HEIGHT / 2);

    const char* text = "Game Over";
    for (const char* c = text; *c != '\0'; c++) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, *c);
    }

    glRasterPos2i(WIDTH / 2 - 100, HEIGHT / 2 - 30);
    const char* restartText = "Press 'R' to restart";
    for (const char* c = restartText; *c != '\0'; c++) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, *c);
    }

    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();

    glEnable(GL_LIGHTING);
    glEnable(GL_TEXTURE_2D);
}

void drawHUD() {
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();
    gluOrtho2D(0, WIDTH, 0, HEIGHT);

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();

    // Draw timer
    glColor3f(1.0f, 1.0f, 1.0f);
    glRasterPos2i(10, HEIGHT - 20);
    std::string timerText;
    if (!timerStarted) {
        timerText = "Press UP to start";
    }
    else {
        timerText = "Time: " + std::to_string(static_cast<int>(gameTimer));
    }
    for (char c : timerText) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);
    }

    // Draw win text
    if (gameWon) {
        glColor3f(0.0f, 1.0f, 0.0f);
        glRasterPos2i(WIDTH / 2 - 100, HEIGHT / 2);
        std::string winText = "You Win! Time: " + std::to_string(playerTime) + " seconds";
        for (char c : winText) {
            glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);
        }
    }

    if (gameOver) {
        drawGameOverText();
    }

    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
}


//=======================================================================
// Game Over Screen
//======================================================================

void resetGame() {
    gravityEnabled = false;
    gameOver = false;
    carPosition = Vector(0, 0, 0);  // Reset car position
    carRotation = 0;  // Reset car rotation
    carSpeed = 0;  // Reset car speed
    wheelRotationX = 0;  // Reset wheel rotation
    wheelRotationY = 0;  // Reset wheel rotation
    sunsetProgress = 0.0f;  // Reset sunset progress
    gameWon = false;
    gameTimer = 90.0f;
    playerTime = 0.0f;

}



//=======================================================================
// Material Configuration Function
//======================================================================
void InitMaterial()
{
	// Enable Material Tracking
	glEnable(GL_COLOR_MATERIAL);

	// Sich will be assigneet Material Properties whd by glColor
	glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);

	// Set Material's Specular Color
	// Will be applied to all objects
	GLfloat specular[] = { 1.0f, 1.0f, 1.0f, 1.0f };
	glMaterialfv(GL_FRONT, GL_SPECULAR, specular);

	// Set Material's Shine value (0->128)
	GLfloat shininess[] = { 96.0f };
	glMaterialfv(GL_FRONT, GL_SHININESS, shininess);
}

//=======================================================================
// OpengGL Configuration Function
//=======================================================================
void myInit(void)
{
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(fovy, aspectRatio, zNear, zFar);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(Eye.x, Eye.y, Eye.z, At.x, At.y, At.z, Up.x, Up.y, Up.z);
    InitLightSource();
    InitMaterial();
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_NORMALIZE);
    glEnable(GL_TEXTURE_2D);
}

//=======================================================================
// Render Functions
//=======================================================================
void RenderGround()
{
	glDisable(GL_LIGHTING);	// Disable lighting 

	glColor3f(0.6, 0.6, 0.6);	// Dim the ground texture a bit

	glEnable(GL_TEXTURE_2D);	// Enable 2D texturing

	glBindTexture(GL_TEXTURE_2D, tex_ground.texture[0]);	// Bind the ground texture

	glPushMatrix();
	glBegin(GL_QUADS);
	glNormal3f(0, 1, 0);	// Set quad normal direction.
	glTexCoord2f(0, 0);		// Set tex coordinates ( Using (0,0) -> (5,5) with texture wrapping set to GL_REPEAT to simulate the ground repeated grass texture).
	glVertex3f(-20, 0, -20);
	glTexCoord2f(5, 0);
	glVertex3f(20, 0, -20);
	glTexCoord2f(5, 5);
	glVertex3f(20, 0, 20);
	glTexCoord2f(0, 5);
	glVertex3f(-20, 0, 20);
	glEnd();
	glPopMatrix();

	glEnable(GL_LIGHTING);	// Enable lighting again for other entites coming throung the pipeline.

	glColor3f(1, 1, 1);	// Set material back to white instead of grey used for the ground texture.
}

void renderCones() {
    for (const auto& cone : cones) {
        glPushMatrix();
        glTranslatef(cone.x, cone.y, cone.z);
        glScalef(1.0f, 1.0f, 1.0f);  // Adjust scale if needed
        glRotatef(90.0f, 0, 1, 0);   // Adjust rotation if needed
        coneModel.DrawModel();
        glPopMatrix();
    }
}

void renderNitros() {
    for (const auto& nitro : nitros) {
        float rotation = -nitro.animationPhase * 45;

        glPushMatrix();
        glTranslatef(nitro.x, nitro.y, nitro.z);
        glScalef(0.2f, 0.2f, 0.2f);  // Adjust scale if needed
        glRotatef(20, 1, 0, 0);
        glRotatef(rotation, 0, 1, 0);   // Adjust rotation if needed
        nitroModel.DrawModel();
        glPopMatrix();
    }
}

//=======================================================================
// Display Function
//=======================================================================
void myDisplay(void)
{
    static int lastTime = 0;
    int currentTime = glutGet(GLUT_ELAPSED_TIME);
    float deltaTime = (currentTime - lastTime) / 1000.0f;
    lastTime = currentTime;
    handleCarControls(deltaTime);
    updateCarPosition(deltaTime);
    updateSunPosition(deltaTime);
    updateNitroAnimation();
    carPosition.print();
    glClearColor(currentSkyColor.r, currentSkyColor.g, currentSkyColor.b, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    updateCamera();
    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition);
    glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmbient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiffuse);
    //// Draw Ground
    //RenderGround();
    // Draw Tree Model
    glPushMatrix();
    glTranslatef(10, 0, 0);
    glScalef(0.7, 0.7, 0.7);
    model_tree.Draw();
    glPopMatrix();
    // Draw house Model
    //glPushMatrix();
    //glRotatef(90.f, 1, 0, 0);
    //model_house.Draw();
    //glPopMatrix();
    //trynna draw a bugatti
    //glPushMatrix();
    //glTranslatef(0, 0, 0);  // Position your model
    //glScalef(0.3, 0.3, 0.3);  // Scale if needed
    //glRotatef(90, 1, 0, 0);  // Rotate if needed
    //model_bugatti.Draw();
    //glPopMatrix();
    //glPushMatrix();
    //glTranslatef(0, 0, 0);  // Position your model
    //glScalef(1.0, 1.0, 1.0);  // Scale if needed
    //glRotatef(0, 1, 0, 0);  // Rotate if needed
    //model_moscow.Draw();
    //glPopMatrix();
    // use tinygltf to draw gltf model
    //glPushMatrix();
    //glTranslatef(0, 0, 0);  // Position your model
    //glScalef(0.09, 0.09, 0.09);  // Scale if needed
    //glRotatef(0, 1, 0, 0);  // Rotate if needed
    //GLTFModel::DrawModel(gltfModel, "models/test/scene.gltf");
    //glPopMatrix();
    // In your render function
    glPushMatrix();
    glTranslatef(0, 0, 0);  // Position your model
    glScalef(1, 1, 1);  // Scale if needed
    glRotatef(90, 0, 1, 0);  // Rotate if needed
    gltfModel1.DrawModel();
    glPopMatrix();
    //glPushMatrix();
    //glTranslatef(1, 1, 1);  // Position your model
    //glScalef(0.5, 0.5, 0.5);  // Scale if needed
    //glRotatef(180, 0, 1, 0);  // Rotate if needed
    //nitroModel.DrawModel();
    //glPopMatrix();
    renderCones();
    renderNitros();
    // Update car model position and rotation
    glPushMatrix();
    glTranslatef(carPosition.x, carPosition.y, carPosition.z);
    glRotatef(carRotation, 0, 1, 0);
    //glScalef(1, 1, 1);
    glRotatef(0, 0, 1, 0);
    carModel1.DrawModel();
    glPopMatrix();
    // Offsets for the wheels relative to the car's position
    float wheelOffsetX = -1.15f; // Horizontal offset from the car's center
    float wheelOffsetY = 0.5f; // Vertical offset below the car
    float wheelOffsetZFront = -1.7f; // Forward offset for front wheels
    float wheelOffsetZBack = 1.7f; // Backward offset for back wheels
    // Draw back left wheel
    glPushMatrix();
    //glScalef(1, 1, 1); 
    glTranslatef(carPosition.x, carPosition.y, carPosition.z);
    glRotatef(carRotation, 0, 1, 0);  // to face the right direction
    glTranslatef(-wheelOffsetX, wheelOffsetY, wheelOffsetZFront);
    glRotatef(wheelRotationX, 1, 0, 0);  // rotate on x here when clicking up or down
    glRotatef(180, 0, 1, 0);  // to face the right direction
    redWheelsBackLeft1.DrawModel();
    glPopMatrix();
    // Draw back right wheel
    glPushMatrix();
    glTranslatef(carPosition.x, carPosition.y, carPosition.z);
    glRotatef(carRotation, 0, 1, 0);  // to face the right direction
    glTranslatef(wheelOffsetX, wheelOffsetY, wheelOffsetZFront);
    //glScalef(0.5, 0.5, 0.5);
    glRotatef(wheelRotationX, 1, 0, 0);  // rotate on x here when clicking up or down
    glRotatef(0, 0, 1, 0);
    redWheelsBackRight1.DrawModel();
    glPopMatrix();
    if (wheelRotationY > 52.5) {
        wheelRotationY = 52.5;
    }
    if (wheelRotationY < -52.5) {
        wheelRotationY = -52.5;
    }
    // Draw front left wheel
    glPushMatrix();
    glTranslatef(carPosition.x, carPosition.y, carPosition.z);
    glRotatef(carRotation, 0, 1, 0);  // to face the right direction
    glTranslatef(-wheelOffsetX, wheelOffsetY, wheelOffsetZBack);
    //glScalef(0.5, 0.5, 0.5);
    glRotatef(180 + wheelRotationY, 0, 1, 0);
    glRotatef(-wheelRotationX, 1, 0, 0);  // rotate on x here when clicking up or 
    redWheelsFrontLeft1.DrawModel();
    glPopMatrix();
    // Draw front right wheel
    glPushMatrix();
    glTranslatef(carPosition.x, carPosition.y, carPosition.z);
    glRotatef(carRotation, 0, 1, 0);  // to face the right direction
    glTranslatef(wheelOffsetX, wheelOffsetY, wheelOffsetZBack);	//glScalef(0.5, 0.5, 0.5);
    glRotatef(wheelRotationY, 0, 1, 0);
    glRotatef(wheelRotationX, 1, 0, 0);  // rotate on x here when clicking up or 
    redWheelsFrontRight1.DrawModel();
    glPopMatrix();
    if (sunVisibility > 0.0f) {
        glPushMatrix();
        glTranslatef(sunPosition.x, sunPosition.y, sunPosition.z);
        glDisable(GL_LIGHTING);
        glColor4f(sunColor.r, sunColor.g, sunColor.b, sunVisibility);
        glEnable(GL_LIGHTING);
        glPopMatrix();
    }
    // Update car model position and rotation
    glPushMatrix();
    glTranslatef(112.226, 0, 235.23 - 9);
    glRotatef(270, 0, 1, 0);
    glScalef(1.2, 1.2, 1.2);
    finishModel.DrawModel();
    glPopMatrix();
    // Draw skybox
    glPushMatrix();
    GLUquadricObj* qobj;
    qobj = gluNewQuadric();
    glTranslated(50, 0, 0);
    glRotated(90, 1, 0, 1);
    glBindTexture(GL_TEXTURE_2D, tex);
    gluQuadricTexture(qobj, true);
    gluQuadricNormals(qobj, GL_SMOOTH);
    gluSphere(qobj, 1000, 100, 100);
    gluDeleteQuadric(qobj);
    glPopMatrix();

    
    drawHUD();


    glutSwapBuffers();
}


//=======================================================================
// Keyboard Function
//=======================================================================
void myKeyboard(unsigned char button, int x, int y)
{
    if(gameOver || gameWon)
        {
		if (button == 'r' || button == 'R')
		{
			resetGame();
		}
		return;
	}
	switch (button)
	{
	case 'w':
		if (currentView == THIRD_PERSON)
			thirdPersonOffset.y += thirdPersonMovementSpeed;
		break;
	case 's':
		if (currentView == THIRD_PERSON)
			thirdPersonOffset.y -= thirdPersonMovementSpeed;
		break;
	case 'a':
		if (currentView == THIRD_PERSON)
			thirdPersonOffset.x -= thirdPersonMovementSpeed;
		break;
	case 'd':
		if (currentView == THIRD_PERSON)
			thirdPersonOffset.x += thirdPersonMovementSpeed;
		break;
	case 'q':
		if (currentView == THIRD_PERSON)
			thirdPersonOffset.z += thirdPersonMovementSpeed;
		break;
	case 'e':
		if (currentView == THIRD_PERSON)
			thirdPersonOffset.z -= thirdPersonMovementSpeed;
		break;
    case 'r':
    case 'R':
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        break;
	case '1':
		currentView = INSIDE_FRONT;
		break;
	case '3':
		currentView = THIRD_PERSON;
		break;
	//case 'j': // Rotate camera left
	//	if (currentView == INSIDE_FRONT)
	//		cameraYaw += cameraRotationSpeed;
	//	else if (currentView == THIRD_PERSON)
	//		thirdPersonYaw += cameraRotationSpeed;
	//	break;
	//case 'l': // Rotate camera right
	//	if (currentView == INSIDE_FRONT)
	//		cameraYaw -= cameraRotationSpeed;
	//	else if (currentView == THIRD_PERSON)
	//		thirdPersonYaw -= cameraRotationSpeed;
	//	break;
	//case 'i': // Rotate camera up
	//	if (currentView == INSIDE_FRONT)
	//		cameraPitch += cameraRotationSpeed;
	//	else if (currentView == THIRD_PERSON)
	//		thirdPersonPitch += cameraRotationSpeed;
	//	break;
	//case 'k': // Rotate camera down
	//	if (currentView == INSIDE_FRONT)
	//		cameraPitch -= cameraRotationSpeed;
	//	else if (currentView == THIRD_PERSON)
	//		thirdPersonPitch -= cameraRotationSpeed;
	//	break;
	case 27:
		exit(0);
		break;
	default:
		break;
	}
	glutPostRedisplay();
}

void specialKeyboard(int key, int x, int y)
{
    if (gameOver) {
        return;
    }

	switch (key)
	{
	case GLUT_KEY_LEFT:
		wheelRotationY += 15.0f;
		break;
	case GLUT_KEY_RIGHT:
		wheelRotationY -= 15.0f;
		break;
	case GLUT_KEY_UP:
		wheelRotationX += 6.0f;
		isAccelerating = true;
		isBraking = false;
        if (!timerStarted) {
            timerStarted = true;
        }
		break;
	case GLUT_KEY_DOWN:
		wheelRotationX -= 6.0f;
		isAccelerating = false;
		isBraking = true;
		break;
	}
	glutPostRedisplay();
}

void specialKeyboardUp(int key, int x, int y)
{
	switch (key)
	{
	case GLUT_KEY_LEFT:
	case GLUT_KEY_RIGHT:
		wheelRotationY = 0.0f; // Reset wheel rotation when key is released
		break;
	case GLUT_KEY_UP:
		isAccelerating = false;
		break;
	case GLUT_KEY_DOWN:
		isBraking = false;
		break;
	}
	glutPostRedisplay();
}

//=======================================================================
// Motion Function
//=======================================================================
void myMotion(int x, int y)
{
	y = HEIGHT - y;

	if (cameraZoom - y > 0)
	{
		Eye.x += -0.1;
		Eye.z += -0.1;
	}
	else
	{
		Eye.x += 0.1;
		Eye.z += 0.1;
	}

	cameraZoom = y;

	glLoadIdentity();	//Clear Model_View Matrix

	gluLookAt(Eye.x, Eye.y, Eye.z, At.x, At.y, At.z, Up.x, Up.y, Up.z);	//Setup Camera with modified paramters

	GLfloat light_position[] = { 0.0f, 10.0f, 0.0f, 1.0f };
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);

	glutPostRedisplay();	//Re-draw scene 
}

//=======================================================================
// Mouse Function
//=======================================================================
void myMouse(int button, int state, int x, int y)
{
	y = HEIGHT - y;

	if (state == GLUT_DOWN)
	{
		cameraZoom = y;
	}
}

//=======================================================================
// Reshape Function
//=======================================================================
void myReshape(int w, int h)
{
	if (h == 0) {
		h = 1;
	}

	WIDTH = w;
	HEIGHT = h;

	// set the drawable region of the window
	glViewport(0, 0, w, h);

	// set up the projection matrix 
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(fovy, (GLdouble)WIDTH / (GLdouble)HEIGHT, zNear, zFar);

	// go back to modelview matrix so we can move the objects about
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(Eye.x, Eye.y, Eye.z, At.x, At.y, At.z, Up.x, Up.y, Up.z);
}

//=======================================================================
// Assets Loading Function
//=======================================================================
void LoadAssets()
{
	// Loading Model files
	model_house.Load("Models/house/house.3DS");
	model_tree.Load("Models/tree/Tree1.3ds");
	model_bugatti.Load("Models/bugatti/Bugatti_Bolide_2024_Modified_CSB.3ds");

	if (!gltfModel1.LoadModel("models/lets-a-go/scene.gltf")) {
		std::cerr << "Failed to load GLTF model" << std::endl;
		// Handle error
	}

	if (!carModel1.LoadModel("models/red-car-no-wheels/scene.gltf")) {
		std::cerr << "Failed to load GLTF model" << std::endl;
		// Handle error
	}

	if (!redWheelsFrontLeft1.LoadModel("models/wheel/scene.gltf")) {
		std::cerr << "Failed to load GLTF model" << std::endl;
		// Handle error
	}

	if (!redWheelsFrontRight1.LoadModel("models/wheel/scene.gltf")) {
		std::cerr << "Failed to load GLTF model" << std::endl;
		// Handle error
	}

	if (!redWheelsBackLeft1.LoadModel("models/wheel/scene.gltf")) {
		std::cerr << "Failed to load GLTF model" << std::endl;
		// Handle error
	}

	if (!redWheelsBackRight1.LoadModel("models/wheel/scene.gltf")) {
		std::cerr << "Failed to load GLTF model" << std::endl;
		// Handle error
	}

    //if (!coneModel.LoadModel("models/nitro2/scene.gltf")) {
    //    std::cerr << "Failed to load GLTF model" << std::endl;
    //    // Handle error
    //}

    if (!nitroModel.LoadModel("models/nitro2/scene.gltf")) {
        std::cerr << "Failed to load GLTF model" << std::endl;
        // Handle error
    }

    if (!coneModel.LoadModel("models/cone/scene.gltf")) {
        std::cerr << "Failed to load GLTF model" << std::endl;
        // Handle error
    }

    if (!finishModel.LoadModel("models/finish/scene.gltf")) {
        std::cerr << "Failed to load GLTF model" << std::endl;
        // Handle error
    }

	glTranslatef(carPosition.x, carPosition.y, carPosition.z);

	// Loading texture files
	loadBMP(&tex, "Textures/blu-sky-3.bmp", true);
}

//=======================================================================
// Main Function
//=======================================================================

void timer(int value) {
	glutPostRedisplay();
	glutTimerFunc(16, timer, 0);
}

void main(int argc, char** argv)
{

	glutInit(&argc, argv);

	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);

	glutInitWindowSize(WIDTH, HEIGHT);

	glutInitWindowPosition(100, 150);

	glutCreateWindow(title);

	glutDisplayFunc(myDisplay);

	glutKeyboardFunc(myKeyboard);
	glutSpecialFunc(specialKeyboard);
	glutSpecialUpFunc(specialKeyboardUp);



	glutMotionFunc(myMotion);

	glutMouseFunc(myMouse);

	glutReshapeFunc(myReshape);

	myInit();

	LoadAssets();
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_NORMALIZE);
    glEnable(GL_COLOR_MATERIAL);

	glShadeModel(GL_SMOOTH);

	//glut timer 

	glutTimerFunc(0, timer, 0);  // Start the timer


	glutMainLoop();
}
